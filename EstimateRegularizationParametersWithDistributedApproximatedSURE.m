function [	fEstimatedGamma,														...
			afRTildes			] =													...
				EstimateGammaWithDistributedSURE(	...
					ffInputLocations,												...
					iiInputLocationsIndexes,										...
					afMeasurements,													...
					afPotentialGammas,												...
					EA,																...
					tKernelParameters												)
	%
	% initialize with dummy values
	fEstimatedGamma	= -1;
	fBestRTilde		= 9999999999999999;
	afRTildes		= zeros( size( afPotentialGammas ));
	%
	% for readability
	G		= ComputeG( iiInputLocationsIndexes, EA, tKernelParameters );
	Lambda	= diag( tKernelParameters.afEigenvalues(1:EA) );
	M		= numel( afMeasurements );
	sigma2	= tKernelParameters.sigma2;
	%
	% cycle on the potential noise levels
	for iGammaIndex = 1:numel(afPotentialGammas);
		%
		gamma = afPotentialGammas(iGammaIndex);
		%
		HS =												...
			( G' * G / M )									...
			*												...
			inv (											...
					( G' * G / M )							...
					+										...
					gamma * ( sigma2 / M ) * inv( Lambda )	...
				);
		%
		Sigma = sigma2 * ( G' * G ) / M^2;
		%
		afRTildes(iGammaIndex) =									...
				norm(		( G' * afMeasurements / M )				...
						-	HS * ( G' * afMeasurements / M )	)^2	...
			+	2 * trace( HS * Sigma );
		%
		% save the current gamma if it is the best one
		if afRTildes(iGammaIndex) < fBestRTilde;
			%
			fBestRTilde = afRTildes(iGammaIndex);
			fEstimatedGamma = gamma;
			%
		end;%
		%
	end;% cycle on the potential noise levels
	%
end % function

