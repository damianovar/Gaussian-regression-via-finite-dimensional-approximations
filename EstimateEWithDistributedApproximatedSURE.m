function [	fEstimatedE,															...
			fEstimatedGamma,														...
			aafRTildes			] =													...
				EstimateEWithDistributedApproximatedSURE(							...
					ffInputLocations,												...
					iiInputLocationsIndexes,										...
					afMeasurements,													...
					afPotentialGammas,												...
					Emax,															...
					tKernelParameters												)
	%
	%
	% initialize with dummy values
	fEstimatedE		= -1;
	fBestRTilde		= 9999999999999999;
	aafRTildes		= zeros( size( 1:Emax ));
	%
	% for readability
	G		= ComputeG( iiInputLocationsIndexes, Emax, tKernelParameters );
	Lambda	= diag( tKernelParameters.afEigenvalues(1:Emax) );
	M		= numel( afMeasurements );
	sigma2	= tKernelParameters.fConfidenceFactor * tKernelParameters.sigma2;
	%
	% cycle on the potential parameters
	for iGammaIndex = 1:numel(afPotentialGammas);
	for E = 1:Emax;
		%
		% for readability
		gamma = afPotentialGammas(iGammaIndex);
		mathcalI = blkdiag( eye(E) , zeros(Emax - E) ); 
		%
		HS =												...
			( G' * G / M )									...
			*												...
			mathcalI										...
			*												...
			inv (											...
					( G' * G / M )							...
					+										...
					gamma * ( sigma2 / M ) * inv( Lambda )	...
				)											...
			*												...
			mathcalI;
		%
		Sigma = sigma2 * ( G' * G ) / M^2;
		%
		aafRTildes(E, iGammaIndex) =								...
				norm(		( G' * afMeasurements / M )				...
						-	HS * ( G' * afMeasurements / M )	)^2	...
			+	2 * trace( HS * Sigma );
		%
		% save the current E if it is the best one
		if aafRTildes(E, iGammaIndex) < fBestRTilde;
			%
			fBestRTilde = aafRTildes(E, iGammaIndex);
			fEstimatedE = E;
			fEstimatedGamma = gamma;
			%
		end;%
		%
	end;% 
	end;% double cycle on the potential hyperparameters
	%
end % function

